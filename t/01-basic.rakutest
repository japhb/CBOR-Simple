use v6.d;
use Test;

use CBOR::Simple;

plan 60;


#| Round trip testing to a hex stringification of the CBOR blob
multi matches(Mu $value, Str:D $cbor) {
    matches($value, buf8.new($cbor.comb(2).map(*.parse-base(16))))
}

#| Round trip testing directly to a CBOR blob
multi matches(Mu $value, Buf:D $cbor) {
    subtest "$value.raku() handled correctly", {
        my $as-cbor  = cbor-encode($value);
        my $as-value = cbor-decode($cbor);

        is-deeply $as-cbor,  $cbor,  "cbor-encode produces correct blob";
        is-deeply $as-value, $value, "cbor-decode produces correct value" if $value  ~~ Any;
        is        $as-value, Mu,     "cbor-decode produces correct value" if $value !~~ Any;
    }
}


#| Unidirectional ENcoding testing, matching a hex stringification of the expected CBOR blob
multi encodes-to(Mu $value, Str:D $cbor) {
    encodes-to($value, buf8.new($cbor.comb(2).map(*.parse-base(16))))
}

#| Unidirectional ENcoding testing, matching an expected CBOR blob
multi encodes-to(Mu $value, Buf:D $cbor) {
    my $as-cbor = cbor-encode($value);
    is-deeply $as-cbor, $cbor, "cbor-encode($value.raku) produces correct blob"
}


#| Unidirectional DEcoding testing, from a hex stringification of the actual CBOR blob
multi decodes-to(Mu $value, Str:D $cbor) {
    decodes-to($value, buf8.new($cbor.comb(2).map(*.parse-base(16))))
}

#| Unidirectional DEcoding testing, from an actual CBOR blob
multi decodes-to(Mu $value, Buf:D $cbor) {
    my $as-value = cbor-decode($cbor);
    my $as-hex   = $cbor.map(*.base(16)).join;

    if $value ~~ Any {
        is-deeply $as-value, $value, "cbor-decode($as-hex) produces correct value"
    }
    else {
        is        $as-value, $value, "cbor-decode($as-hex) produces correct value"
    }
}


### Below adapted from https://tools.ietf.org/html/rfc8949#appendix-A

# INTEGERS

matches   0, '00';
matches   1, '01';
matches  10, '0a';
matches  23, '17';
matches  24, '1818';
matches  25, '1819';
matches 100, '1864';

matches                  1000, '1903e8';
matches               1000000, '1a000f4240';
matches         1000000000000, '1b000000e8d4a51000';
matches  18446744073709551615, '1bffffffffffffffff';
matches -18446744073709551616, '3bffffffffffffffff';
matches  18446744073709551616, 'c249010000000000000000';
matches -18446744073709551617, 'c349010000000000000000';

matches    -1, '20';
matches   -10, '29';
matches  -100, '3863';
matches -1000, '3903e7';


# FLOATS

# XXXX: Requires 16-bit nums
# matches   0.0e0, 'f90000';
# matches  -0.0e0, 'f98000';
# matches   1.0e0, 'f93c00';
# matches   1.5e0, 'f93e00';
# matches 65504e0, 'f97bff';

matches    1.1e0, 'fb3ff199999999999a';
matches 100000e0, 'fa47c35000';
matches 3.4028234663852886e+38, 'fa7f7fffff';
matches 1.0e+300, 'fb7e37e43c8800759c';
matches   -4.1e0, 'fbc010666666666666';

# XXXX: Requires 16-bit nums
# matches 5.960464477539063e-8, 'f90001';
# matches 0.00006103515625e0,   'f90400';

# matches -4.0e0, 'f9c400';
# matches    Inf, 'f97c00';
# matches    NaN, 'f97e00';
# matches   -Inf, 'f9fc00';

# Current state: No 16-bit num support, so these all produce 32-bit output.
# XXXX: This isn't ideal (all should produce 16-bit output), but it's not
#       *wrong*, so for now just prevent regression.
encodes-to  Inf, 'fa7f800000';
encodes-to  NaN, 'fa7fc00000';
encodes-to -Inf, 'faff800000';

decodes-to  Inf, 'fa7f800000';
decodes-to  NaN, 'fa7fc00000';
decodes-to -Inf, 'faff800000';

decodes-to  Inf, 'fb7ff0000000000000';
decodes-to  NaN, 'fb7ff8000000000000';
decodes-to -Inf, 'fbfff0000000000000';


# SIMPLE VALUES

matches False, 'f4';
matches True,  'f5';
matches Any,   'f6';
matches Mu,    'f7';

# XXXX: Other simples


# TAGGED VALUES

decodes-to DateTime.new("2013-03-21T20:04:00Z"),
           'c074323031332d30332d32315432303a30343a30305a';
matches DateTime.new(1363896240),   'c11a514b67b0';
matches DateTime.new(1363896240.5), 'c1fb41d452d9ec200000';

# XXXX: Other known tags


# BINARY BUFFERS

matches buf8.new,          '40';
matches buf8.new(1,2,3,4), '4401020304';


# STRINGS

matches "",       '60';
matches "a",      '6161';
matches "IETF",   '6449455446';
matches "\"\\",   '62225c';
matches "\x00fc", '62c3bc';
matches "\x6c34", '63e6b0b4';

my $utf16 = blob16.new(0xd800, 0xdd51);
my $str   = $utf16.decode('utf-16');
matches $str, '64f0908591';


# ARRAYS

matches [],                  '80';
matches [1, 2, 3],           '83010203';
matches [1, [2, 3], [4, 5]], '8301820203820405';
matches (my @ = 1..25),      '98190102030405060708090a0b0c0d0e0f101112131415161718181819';


# MAPS

matches {},                    'a0';
my %intkey{Mu} = 1, 2, 3, 4;
matches %intkey,               'a201020304';
matches {a => 1, b => [2, 3]}, 'a26161016162820203';
matches ["a", {b => "c"}],     '826161a161626163';
matches {a => "A", b => "B", c => "C", d => "D", e => "E"},
        'a56161614161626142616361436164614461656145';


# INDEFINITE LENGTH VALUES

decodes-to buf8.new(1,2,3,4,5), '5f42010243030405ff';
decodes-to "streaming",         '7f657374726561646d696e67ff';

# This test from section 3.2.3 of https://tools.ietf.org/html/rfc8949
decodes-to buf8.new(0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x99),
           '5f44aabbccdd43eeff99ff';

# XXXX: Indefinite length arrays and maps



done-testing;
