use v6.d;
use Test;

use CBOR::Simple;

plan 106;


#| Simple converter utility: hex string to binary buf
sub hex-decode(Str:D $hex, $buf-type = buf8) {
    $buf-type.new($hex.comb(2).map(*.parse-base(16)))
}

#| Round trip testing to a hex stringification of the CBOR blob
multi matches(Mu $value, Str:D $cbor) {
    matches($value, hex-decode($cbor))
}

#| Round trip testing directly to a CBOR blob
multi matches(Mu $value, Buf:D $cbor) {
    subtest "$value.raku() handled correctly", {
        my $as-cbor  = cbor-encode($value);
        my $as-value = cbor-decode($cbor);

        is-deeply $as-cbor,  $cbor,  "cbor-encode produces correct blob";
        is-deeply $as-value, $value, "cbor-decode produces correct value" if $value  ~~ Any;
        is        $as-value, Mu,     "cbor-decode produces correct value" if $value !~~ Any;
    }
}


#| Unidirectional ENcoding testing, matching a hex stringification of the expected CBOR blob
multi encodes-to(Mu $value, Str:D $cbor) {
    encodes-to($value, hex-decode($cbor))
}

#| Unidirectional ENcoding testing, matching an expected CBOR blob
multi encodes-to(Mu $value, Buf:D $cbor) {
    my $as-cbor = cbor-encode($value);
    is-deeply $as-cbor, $cbor, "cbor-encode({$value.raku}) produces correct blob"
}


#| Unidirectional DEcoding testing, from a hex stringification of the actual CBOR blob
multi decodes-to(Mu $value, Str:D $cbor) {
    decodes-to($value, hex-decode($cbor))
}

#| Unidirectional DEcoding testing, from an actual CBOR blob
multi decodes-to(Mu $value, Buf:D $cbor) {
    my $as-value = cbor-decode($cbor);
    my $as-hex   = $cbor.map(*.fmt('%02X')).join;

    if $value ~~ Any {
        is-deeply $as-value, $value, "cbor-decode($as-hex) produces correct value"
    }
    else {
        is        $as-value, $value, "cbor-decode($as-hex) produces correct value"
    }
}


### Below adapted from https://tools.ietf.org/html/rfc8949#appendix-A

# INTEGERS

matches   0, '00';
matches   1, '01';
matches  10, '0a';
matches  23, '17';
matches  24, '1818';
matches  25, '1819';
matches 100, '1864';

matches                  1000, '1903e8';
matches               1000000, '1a000f4240';
matches         1000000000000, '1b000000e8d4a51000';
matches  18446744073709551615, '1bffffffffffffffff';
matches -18446744073709551616, '3bffffffffffffffff';
matches  18446744073709551616, 'c249010000000000000000';
matches -18446744073709551617, 'c349010000000000000000';

matches    -1, '20';
matches   -10, '29';
matches  -100, '3863';
matches -1000, '3903e7';


# FLOATS

# XXXX: Requires write support for 16-bit nums
# matches   0.0e0, 'f90000';
# matches  -0.0e0, 'f98000';
# matches   1.0e0, 'f93c00';
# matches   1.5e0, 'f93e00';
# matches 65504e0, 'f97bff';
decodes-to   0.0e0, 'f90000';
decodes-to  -0.0e0, 'f98000';
decodes-to   1.0e0, 'f93c00';
decodes-to   1.5e0, 'f93e00';
decodes-to 65504e0, 'f97bff';

matches    1.1e0, 'fb3ff199999999999a';
matches 100000e0, 'fa47c35000';
matches 3.4028234663852886e+38, 'fa7f7fffff';
matches 1.0e+300, 'fb7e37e43c8800759c';
matches   -4.1e0, 'fbc010666666666666';

# XXXX: Requires write support for 16-bit nums
# matches 5.960464477539063e-8, 'f90001';
# matches 0.00006103515625e0,   'f90400';
decodes-to 5.960464477539063e-8, 'f90001';
decodes-to 0.00006103515625e0,   'f90400';

# XXXX: Requires write support for general 16-bit nums
# matches -4.0e0, 'f9c400';
decodes-to -4.0e0, 'f9c400';

# Â±Inf and NaN should encode to 16 bits by default
matches     Inf, 'f97c00';
matches     NaN, 'f97e00';
matches    -Inf, 'f9fc00';

decodes-to  Inf, 'fa7f800000';
decodes-to  NaN, 'fa7fc00000';
decodes-to -Inf, 'faff800000';

decodes-to  Inf, 'fb7ff0000000000000';
decodes-to  NaN, 'fb7ff8000000000000';
decodes-to -Inf, 'fbfff0000000000000';


# SIMPLE VALUES

matches False, 'f4';
matches True,  'f5';
matches Any,   'f6';
matches Mu,    'f7';

# XXXX: Other simples


# TAGGED VALUES

decodes-to DateTime.new("2013-03-21T20:04:00Z"),
           'c074323031332d30332d32315432303a30343a30305a';
matches Instant.from-posix(1363896240),   'c11a514b67b0';
matches Instant.from-posix(1363896240.5), 'c1fb41d452d9ec200000';

# RFC 8943 date extension tests adapted from
# https://www.rfc-editor.org/rfc/rfc8943.html#name-example-date-representation
matches    Date.new('1940-10-09'), 'd8643929b3';
matches    Date.new('1980-12-08'), 'd864190f9a';
decodes-to Date.new('1940-10-09'), 'd903ec6a313934302d31302d3039';
decodes-to Date.new('1980-12-08'), 'd903ec6a313938302d31322d3038';

# Decimal Fraction/Bigfloat tests from https://tools.ietf.org/html/rfc8949#section-3.4.4
decodes-to 273.15, 'c48221196ab3';
decodes-to   1.5,  'c582203';

# Tag 24/63: Lazily-decoded CBOR data item/Sequence
my $value = cbor-encode(42);
my $lazy  = CBOR::Simple::Tagged.new(:tag-number(24), :$value);
my $seq   = CBOR::Simple::Tagged.new(:tag-number(63), :$value);
matches $lazy, 'd81842182a';
matches $seq,  'd83f42182a';

# Extension tag 30: Rational number
# First test from http://peteroupc.github.io/CBOR/rational.html, the rest by me
matches 1/3,   'd81e820103';

matches 3/7,   'd81e820307';
matches -4/11, 'd81e82230b';
matches Rat.new(    18446744073709551614, 18446744073709551615),
        'd81e821bfffffffffffffffe1bffffffffffffffff';
matches FatRat.new( 18446744073709551615, 18446744073709551616),
        'd81e821bffffffffffffffffc249010000000000000000';
matches Rat.new(   -18446744073709551614, 18446744073709551615),
        'd81e823bfffffffffffffffd1bffffffffffffffff';
matches FatRat.new(-18446744073709551615, 18446744073709551616),
        'd81e823bfffffffffffffffec249010000000000000000';

# Extension tag 31: Absent values
# Tests from https://github.com/svaarala/cbor-specs/blob/master/cbor-absent-tag.rst
my @with-nils = ['foo', 1, 2, 'bar'];
@with-nils.BIND-POS($_, Nil) for 1..2;
encodes-to @with-nils, '8463666f6fd81ff7d81ff763626172';
decodes-to ['foo', Mu, Mu, 'bar'], '8463666f6ff7f763626172';

# Extension tag 258: Set
matches (1, 2, 3).Set, 'd9010283010203';
matches < a b c >.Set, 'd9010283616161626163';

# Extension tag 259: Object-keyed Map; tests adapted from
# https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md
decodes-to (my Any %{Mu} = k1 => "v1", k2 => "v2" ),
           'D90103A2626B31627631626B32627632';
# decodes-to (my Any %{Mu} = 1942 => "v1", k2 => "v2", [1, 2, 3] => "v3" ),
#            'D90103A3190796627631626B3262763283010203627633';
my $hex     = 'D90103A3190796627631626B3262763283010203627633';
my $decoded = cbor-decode(hex-decode($hex));
isa-ok $decoded, Map, "decodes to a Map";
isnt $decoded.keyof.^name, 'Str', "does not have string keys";
is $decoded.AT-KEY(1942), 'v1', "has numeric key";
is $decoded.AT-KEY('k2'), 'v2', "has string key";
my $first = $decoded.keys.first(* eqv [1, 2, 3]);
is $decoded.AT-KEY($first), 'v3', "has array key";

# Tag 55799: Self-describing CBOR
decodes-to 100, 'd9d9f71864';
my $as-cbor = cbor-encode(123, :cbor-self-tag);
is-deeply $as-cbor, hex-decode('d9d9f7187b'),
          "cbor-encode(123, :cbor-self-tag) produces correct blob";

# Tag 55800: Self-describing CBOR Sequence
decodes-to 100, 'd9d9f81864';
my $as-seq = cbor-encode(123, :cbor-sequence-tag);
is-deeply $as-seq, hex-decode('d9d9f8187b'),
          "cbor-encode(123, :cbor-sequence-tag) produces correct blob";


# XXXX: Other known tags


# BINARY BUFFERS

matches buf8.new,          '40';
matches buf8.new(1,2,3,4), '4401020304';


# STRINGS

matches "",       '60';
matches "a",      '6161';
matches "IETF",   '6449455446';
matches "\"\\",   '62225c';
matches "\x00fc", '62c3bc';
matches "\x6c34", '63e6b0b4';

my $utf16 = blob16.new(0xd800, 0xdd51);
my $str   = $utf16.decode('utf-16');
matches $str, '64f0908591';


# ARRAYS

matches [],                  '80';
matches [1, 2, 3],           '83010203';
matches [1, [2, 3], [4, 5]], '8301820203820405';
matches (my @ = 1..25),      '98190102030405060708090a0b0c0d0e0f101112131415161718181819';


# MAPS

matches {},                    'a0';
my %intkey{Mu} = 1, 2, 3, 4;
matches %intkey,               'a201020304';
matches {a => 1, b => [2, 3]}, 'a26161016162820203';
matches ["a", {b => "c"}],     '826161a161626163';
matches {a => "A", b => "B", c => "C", d => "D", e => "E"},
        'a56161614161626142616361436164614461656145';


# INDEFINITE LENGTH VALUES

decodes-to buf8.new(1,2,3,4,5), '5f42010243030405ff';
decodes-to "streaming",         '7f657374726561646d696e67ff';

# This test from section 3.2.3 of https://tools.ietf.org/html/rfc8949
decodes-to buf8.new(0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x99),
           '5f44aabbccdd43eeff99ff';

decodes-to [],                  '9fff';
decodes-to [1, [2, 3], [4, 5]], '9f018202039f0405ffff';
decodes-to [1, [2, 3], [4, 5]], '9f01820203820405ff';
decodes-to [1, [2, 3], [4, 5]], '83018202039f0405ff';
decodes-to [1, [2, 3], [4, 5]], '83019f0203ff820405';
decodes-to (my @ = 1..25),
           '9f0102030405060708090a0b0c0d0e0f101112131415161718181819ff';

decodes-to {a => 1, b => [2, 3]},    'bf61610161629f0203ffff';
decodes-to ["a", {b => "c"}],        '826161bf61626163ff';
decodes-to {Fun => True, Amt => -2}, 'bf6346756ef563416d7421ff';


done-testing;
