use Test;
use lib $*PROGRAM.sibling('lib');
use CodecMatches;

use CBOR::Simple;


plan 22;


### Tests for RFC 8746 typed arrays (https://www.rfc-editor.org/rfc/rfc8746.html)


# DECODE BOTH BIG AND LITTLE ENDIAN ON ANY HOST
# diag "Testing bi-endian decoding";

# num32/num64/num
my $num32-empty-be = 'd85140';
my $num32-empty-le = 'd85540';
my $num64-empty-be = 'd85240';
my $num64-empty-le = 'd85640';
decodes-to array[num32].new(), $_ for $num32-empty-be, $num32-empty-le;
decodes-to array[num64].new(), $_ for $num64-empty-be, $num64-empty-le;

my $num32-basic    = array[num32].new(Inf, -Inf, NaN, 0.0e0, -0.0e0, 1.0e0, 100000e0);
my $num32-basic-be = 'd851581c7f800000ff8000007fc00000'
                   ~ '00000000800000003f80000047c35000';
my $num32-basic-le = 'd855581c0000807f000080ff0000c07f'
                   ~ '00000000000000800000803f0050c347';
decodes-to $num32-basic, $_ for $num32-basic-be, $num32-basic-le;

my $num64-basic    = array[num64].new(Inf, -Inf, NaN, 0.0e0, -0.0e0, 1.1e0, 1.0e+300);
my $num-basic      = array[num  ].new(Inf, -Inf, NaN, 0.0e0, -0.0e0, 1.1e0, 1.0e+300);
my $num64-basic-be = 'd85258387ff0000000000000fff0000000000000'
                   ~ '7ff800000000000000000000000000008000000000000000'
                   ~ '3ff199999999999a7e37e43c8800759c';
my $num64-basic-le = 'd8565838000000000000f07f000000000000f0ff'
                   ~ '000000000000f87f00000000000000000000000000000080'
                   ~ '9a9999999999f13f9c7500883ce4377e';
decodes-to $num64-basic, $_ for $num64-basic-be, $num64-basic-le;


# int16/uint16
my $int16-basic    = array[int16].new(-32768, -32767, -256, -255, -254, -129,
                                      -128, -127, -1, 0, 1, 126, 127, 128, 129,
                                      254, 255, 256, 32766, 32767);
my $int16-basic-be = 'd849582880008001ff00ff01ff02ff7fff80ff81ffff00000001007e'
                   ~ '007f0080008100fe00ff01007ffe7fff';
my $int16-basic-le = 'd84d58280080018000ff01ff02ff7fff80ff81ffffff000001007e00'
                   ~ '7f0080008100fe00ff000001fe7fff7f';
decodes-to $int16-basic, $_ for $int16-basic-be, $int16-basic-le;

my $uint16-basic    = array[uint16].new(0, 1, 126, 127, 128, 129, 254, 255,
                                        256, 32766, 32767, 32768, 65534, 65535);
my $uint16-basic-be = 'd841581c00000001007e007f0080008100fe00ff'
                    ~ '01007ffe7fff8000fffeffff';
my $uint16-basic-le = 'd845581c000001007e007f0080008100fe00ff00'
                    ~ '0001fe7fff7f0080feffffff';
decodes-to $uint16-basic, $_ for $uint16-basic-be, $uint16-basic-le;


# TEST 8-BIT ENDIAN-AGNOSTIC ARRAYS

# int8/uint8/byte
my $uint8-basic    = array[uint8].new(0, 1, 126, 127, 128, 129, 254, 255);
my $byte-basic     = array[byte ].new(0, 1, 126, 127, 128, 129, 254, 255);
my $int8-basic     = array[int8 ].new(-128, -127, -1, 0, 1, 42, 126, 127);
my $uint8-basic-ne = 'd8404800017e7f8081feff';
my $int8-basic-ne  = 'd848488081ff00012a7e7f';
matches $uint8-basic, $uint8-basic-ne;
matches $int8-basic,  $int8-basic-ne;

encodes-to $byte-basic, $uint8-basic-ne;


# TEST FOR APPROPRIATE NATIVE ENDIAN ENCODING

if Kernel.endian == BigEndian {
    # diag "Testing BigEndian native encoding";
    encodes-to array[num32].new(), $num32-empty-be;
    encodes-to array[num64].new(), $num64-empty-be;
    encodes-to $num32-basic,       $num32-basic-be;
    encodes-to $num64-basic,       $num64-basic-be;
    encodes-to $num-basic,         $num64-basic-be;

    encodes-to $int16-basic,       $int16-basic-be;
    encodes-to $uint16-basic,      $uint16-basic-be;
}
# LittleEndian Kernel
else {
    # diag "Testing LittleEndian native encoding";
    encodes-to array[num32].new(), $num32-empty-le;
    encodes-to array[num64].new(), $num64-empty-le;
    encodes-to $num32-basic,       $num32-basic-le;
    encodes-to $num64-basic,       $num64-basic-le;
    encodes-to $num-basic,         $num64-basic-le;

    encodes-to $int16-basic,       $int16-basic-le;
    encodes-to $uint16-basic,      $uint16-basic-le;
}


done-testing;
